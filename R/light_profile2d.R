#' 2D Partial Dependence and other 2D Profiles
#'
#' Calculates different types of 2D-profiles across covariable values. By default, partial dependence profiles are calculated (see Friedman). Other options are response, predicted values ("M plots" or "marginal plots", see Apley), residuals, and shap. The results are aggregated either by (weighted) means or by (weighted) quartiles. Note that ALE profiles are calibrated by (weighted) average predictions.
#'
#' For numeric covariables \code{v1} and \code{v2} with more than \code{n_bins} disjoint values, its values are binned. Alternatively, \code{breaks} can be provided to specify the binning. For partial dependence profiles (and partly also ALE profiles), this behaviour can be overritten either by providing a vector of evaluation points (\code{pd_evaluate_at}) or an evaluation \code{pd_grid}. By the latter we mean a data frame with column name(s) with a (multi-)variate evaluation grid. For partial dependence, and prediction profiles, "model", "predict_function", linkinv" and "data" are required. For response profiles its "y", "linkinv" and "data" and for shap profiles it is just "shap". "data" can be passed on the fly.
#'
#' @importFrom withr with_options
#' @importFrom tidyr expand_grid
#' @importFrom stats setNames
#' @param x An object of class \code{flashlight} or \code{multiflashlight}.
#' @param v The variable to be profiled.
#' @param data An optional \code{data.frame}. Not used for \code{type = "shap"}.
#' @param by An optional vector of column names used to additionally group the results.
#' @param type Type of the profile: Either "partial dependence", "predicted", "response", "residual", or "shap".
#' @param breaks Cut breaks for a numeric \code{v}.
#' @param n_bins Maxmium number of unique values to evaluate for numeric \code{v}. Only used if neither \code{pd_grid} nor \code{pd_evaluate_at} is specified.
#' @param cut_type For the default "equal", bins of equal width are created for \code{v} by \code{pretty}. Choose "quantile" to create quantile bins.
#' @param use_linkinv Should retransformation function be applied? Default is TRUE. Not used for type "shap".
#' @param pd_evaluate_at Vector with values of \code{v} used to evaluate the profile. Only relevant for type = "partial dependence".
#' @param pd_grid A \code{data.frame} with grid values and exactly two columns, e.g. generated by \code{expand.grid}. Only used for type = "partial dependence".
#' @param pd_indices A vector of row numbers to consider in calculating partial dependence profiles. Only used for type = "partial dependence".
#' @param pd_n_max Maximum number of ICE profiles to calculate (will be randomly picked from \code{data}). Only used for type = "partial dependence".
#' @param pd_seed Integer random seed used to select ICE profiles. Only used for type = "partial dependence".
#' @param ... Further arguments passed to \code{cut3} resp. \code{formatC} in forming the cut breaks of the \code{v} variables. Not relevant for partial dependence profiles.
#' @return An object of classes \code{light_profile}, \code{light} (and a list) with the following elements.
#' \itemize{
#'   \item \code{data} A tibble containing results. Can be used to build fully customized visualizations. Its column names are specified by all other items in this list.
#'   \item \code{by} Names of group by variable.
#'   \item \code{v} The variables evaluated.
#'   \item \code{type} Same as input \code{type}. For information only.
#' }
#' @export
#' @references
#' Friedman J. H. (2001). Greedy function approximation: A gradient boosting machine. The Annals of Statistics, 29:1189â€“1232.
#'
#' Apley D. W. (2016). Visualizing the effects of predictor variables in black box supervised learning models.
#'
#' @examples
#' fit <- lm(Sepal.Length ~ ., data = iris)
#' fl <- flashlight(model = fit, label = "iris", data = iris, y = "Sepal.Length")
#' light_profile2d(fl, v = c("Petal.Length", "Species"))
#' light_profile2d(fl, v = c("Petal.Length", "Sepal.Width"),
#'   type = "predicted", by = "Species", n_bins=c(2, 5), sep = ";")
#' @seealso \code{\link{light_effects}}, \code{\link{plot.light_profile}}.
light_profile2d <- function(x, ...) {
  UseMethod("light_profile2d")
}

#' @describeIn light_profile Default method not implemented yet.
#' @export
light_profile2d.default <- function(x, ...) {
  stop("No default method available yet.")
}

#' @describeIn light_profile Profiles for flashlight.
#' @export
light_profile2d.flashlight <- function(x, v = NULL,
                                       data = x$data, by = x$by,
                                       type = c("partial dependence",
                                                "predicted", "response",
                                                "residual", "shap"),
                                       breaks = NULL, n_bins = 11,
                                       cut_type = "equal",
                                       use_linkinv = TRUE,
                                       pd_evaluate_at = NULL, pd_grid = NULL,
                                       pd_indices = NULL, pd_n_max = 1000,
                                       pd_seed = NULL, ...) {
  type <- match.arg(type)

  value_name <- getOption("flashlight.value_name")
  label_name <- getOption("flashlight.label_name")
  type_name <- getOption("flashlight.type_name")

  if (type == "partial dependence" && !is.null(pd_grid)) {
    stopifnot("pd_grid must have exactly two columns" = ncol(pd_grid) == 2L)
    v <- colnames(pd_grid)
  } else {
    stopifnot("Need exactly two 'v'." = length(v) == 2L)
  }

  # If SHAP, extract data
  if (type == "shap") {
    if (!is.shap(x$shap)) {
      stop("No shap values calculated. Run 'add_shap' for the flashlight first.")
    }
    stopifnot(v %in% colnames(x$shap$data))
    variable_name <- getOption("flashlight.variable_name")
    data <- x$shap$data[x$shap$data[[variable_name]] %in% v, ]
  } else if (is.null(data)) {
    data <- x$data
  }

  # Checks (more will be done below or in the called functions)
  stopifnot(
    "No data!" = is.data.frame(data) && nrow(data) >= 1L,
    "'by' not in 'data'!" = by %in% colnames(data),
    "'v' not in 'data'." = v %in% colnames(data),
    !anyDuplicated(c(by, v, value_name, label_name, type_name))
  )

  # Update flashlight
  if (type != "shap") {
    x <- flashlight(x, data = data, by = by,
                    linkinv = if (use_linkinv) x$linkinv else function(z) z)
  }

  # Calculate profiles
  if (type == "partial dependence") {
    # Construct pd_grid
    if (is.null(pd_grid)) {
      if (is.null(pd_evaluate_at)) {
        if (!is.null(breaks)) {
          if (is.list(breaks)) {
            stopifnot(length(breaks) == 2L)
            pd_evaluate_at <- lapply(breaks, midpoints)
          } else {
            pd_evaluate_at <- midpoints(breaks)
          }
        } else {
          temp <- Map(auto_cut, x = data[v], n_bins = n_bins,
                      cut_type = cut_type, ...)
          pd_evaluate_at <- lapply(temp, `[[`, "bin_means")
        }
      }
      if (!is.list(pd_evaluate_at)) {
        pd_evaluate_at <- list(pd_evaluate_at, pd_evaluate_at)
      }
      pd_grid <- setNames(expand.grid(pd_evaluate_at), v)
    }
    withr::with_options(list(flashlight.id_name = "id_xxx"),
      data <- light_ice(
        x = x, grid = pd_grid, indices = pd_indices,
        n_max = pd_n_max, seed = pd_seed)$data
    )
  } else {
    if (type %in% c("response", "residual") && is.null(x$y)) {
      stop("You need to specify 'y' in flashlight.")
    }

    # Add predictions/response to data
    data[[value_name]] <- switch(type,
      response = response(x),
      predicted = predict(x),
      residual = residuals(x),
      shap = data[["shap_"]]
    )

    # Replace v values by binned values (annoying ifelse required)
    if (!is.null(breaks)) {
      cuts <- Map(auto_cut, x = data[v], n_bins = n_bins,
                  cut_type = cut_type, breaks = breaks, ...)
    } else {
      cuts <- Map(auto_cut, x = data[v], n_bins = n_bins,
                  cut_type = cut_type, ...)
    }
    data[v] <- lapply(cuts, `[[`, c("data", "level"))
  }

  # Aggregate predicted values
  agg <- grouped_stats(
    data = data, x = value_name, w = x$w,
    by = c(by, v), na.rm = TRUE, counts = FALSE
  )

  # Finalize results
  agg[[label_name]] <- x$label

  # Collect results
  out <- list(data = agg, by = by, v = v, type = type)
  add_classes(out, c("light_profile2d", "light"))
}

#' @describeIn light_profile Profiles for multiflashlight.
#' @export
light_profile.multiflashlight <- function(x, v = NULL, data = NULL,
                                          breaks = NULL, n_bins = 11,
                                          cut_type = c("equal", "quantile"),
                                          pd_evaluate_at = NULL,
                                          pd_grid = NULL, ...) {
  cut_type <- match.arg(cut_type)

  if (is.null(breaks) && is.null(pd_evaluate_at) && is.null(pd_grid)) {
    breaks <- common_breaks(x = x, v = v, data = data,
                            n_bins = n_bins, cut_type = cut_type)
  }
  all_profiles <- lapply(x, light_profile, v = v, data = data,
                         breaks = breaks, n_bins = n_bins,
                         cut_type = cut_type,
                         pd_evaluate_at = pd_evaluate_at,
                         pd_grid = pd_grid, ...)
  light_combine(all_profiles, new_class = "light_profile_multi")
}
